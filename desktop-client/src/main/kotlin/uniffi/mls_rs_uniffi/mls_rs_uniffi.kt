// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.mls_rs_uniffi;

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.ptr.ByReference
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField
    var capacity: Long = 0
    @JvmField
    var len: Long = 0
    @JvmField
    var data: Pointer? = null

    class ByValue : RustBuffer(), Structure.ByValue
    class ByReference : RustBuffer(), Structure.ByReference

    internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_mls_rs_uniffi_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if (it.data == null) {
                throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
            }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_mls_rs_uniffi_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
    @JvmField
    var len: Int = 0
    @JvmField
    var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}

// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
            val item = read(byteBuf)
            if (byteBuf.hasRemaining()) {
                throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
            }
            return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
public interface FfiConverterRustBuffer<KotlinType> : FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField
    var code: Byte = 0
    @JvmField
    var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue : UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E : Exception> uniffiRustCallWithError(
    errorHandler: UniffiRustCallStatusErrorHandler<E>,
    callback: (UniffiRustCallStatus) -> U
): U {
    var status = UniffiRustCallStatus();
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun <E : Exception> uniffiCheckCallStatus(
    errorHandler: UniffiRustCallStatusErrorHandler<E>,
    status: UniffiRustCallStatus
) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object UniffiNullRustCallStatusErrorHandler : UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback);
}

internal inline fun <T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch (e: Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun <T, reified E : Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch (e: Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}

// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T : Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter = java.util.concurrent.atomic.AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "mls_rs_uniffi"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long, `pollResult`: Byte)
}

internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long)
}

internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long)
}

@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ) : UniffiForeignFuture(`handle`, `free`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructU8(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructU8.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructI8(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructI8.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructU16(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructU16.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructI16(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructI16.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructU32(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructU32.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructI32(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructI32.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructU64(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructU64.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructI64(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructI64.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructF32(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructF32.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructF64(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructF64.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructPointer(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructPointer.UniffiByValue)
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructRustBuffer(`returnValue`, `callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructRustBuffer.UniffiByValue)
}

@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructVoid(`callStatus`), Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }

}

internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long, `result`: UniffiForeignFutureStructVoid.UniffiByValue)
}

internal interface UniffiCallbackInterfaceGroupStateStorageMethod0 : com.sun.jna.Callback {
    fun callback(
        `uniffiHandle`: Long,
        `groupId`: RustBuffer.ByValue,
        `uniffiOutReturn`: RustBuffer,
        uniffiCallStatus: UniffiRustCallStatus,
    )
}

internal interface UniffiCallbackInterfaceGroupStateStorageMethod1 : com.sun.jna.Callback {
    fun callback(
        `uniffiHandle`: Long,
        `groupId`: RustBuffer.ByValue,
        `epochId`: Long,
        `uniffiOutReturn`: RustBuffer,
        uniffiCallStatus: UniffiRustCallStatus,
    )
}

internal interface UniffiCallbackInterfaceGroupStateStorageMethod2 : com.sun.jna.Callback {
    fun callback(
        `uniffiHandle`: Long,
        `groupId`: RustBuffer.ByValue,
        `groupState`: RustBuffer.ByValue,
        `epochInserts`: RustBuffer.ByValue,
        `epochUpdates`: RustBuffer.ByValue,
        `uniffiOutReturn`: Pointer,
        uniffiCallStatus: UniffiRustCallStatus,
    )
}

internal interface UniffiCallbackInterfaceGroupStateStorageMethod3 : com.sun.jna.Callback {
    fun callback(
        `uniffiHandle`: Long,
        `groupId`: RustBuffer.ByValue,
        `uniffiOutReturn`: RustBuffer,
        uniffiCallStatus: UniffiRustCallStatus,
    )
}

@Structure.FieldOrder("state", "epoch", "write", "maxEpochId", "uniffiFree")
internal open class UniffiVTableCallbackInterfaceGroupStateStorage(
    @JvmField internal var `state`: UniffiCallbackInterfaceGroupStateStorageMethod0? = null,
    @JvmField internal var `epoch`: UniffiCallbackInterfaceGroupStateStorageMethod1? = null,
    @JvmField internal var `write`: UniffiCallbackInterfaceGroupStateStorageMethod2? = null,
    @JvmField internal var `maxEpochId`: UniffiCallbackInterfaceGroupStateStorageMethod3? = null,
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
) : Structure() {
    class UniffiByValue(
        `state`: UniffiCallbackInterfaceGroupStateStorageMethod0? = null,
        `epoch`: UniffiCallbackInterfaceGroupStateStorageMethod1? = null,
        `write`: UniffiCallbackInterfaceGroupStateStorageMethod2? = null,
        `maxEpochId`: UniffiCallbackInterfaceGroupStateStorageMethod3? = null,
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    ) : UniffiVTableCallbackInterfaceGroupStateStorage(`state`, `epoch`, `write`, `maxEpochId`, `uniffiFree`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceGroupStateStorage) {
        `state` = other.`state`
        `epoch` = other.`epoch`
        `write` = other.`write`
        `maxEpochId` = other.`maxEpochId`
        `uniffiFree` = other.`uniffiFree`
    }

}


// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            loadIndirect<UniffiLib>(componentName = "mls_rs_uniffi")
                .also { lib: UniffiLib ->
                    uniffiCheckContractApiVersion(lib)
                    uniffiCheckApiChecksums(lib)
                    uniffiCallbackInterfaceGroupStateStorage.register(lib)
                }
        }

        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    fun uniffi_mls_rs_uniffi_fn_clone_client(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_free_client(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_constructor_client_new(
        `id`: RustBuffer.ByValue,
        `signatureKeypair`: RustBuffer.ByValue,
        `clientConfig`: RustBuffer.ByValue,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_method_client_create_group(
        `ptr`: Pointer, `groupId`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_method_client_generate_key_package_message(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_method_client_join_group(
        `ptr`: Pointer,
        `ratchetTree`: RustBuffer.ByValue,
        `welcomeMessage`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_client_load_group(
        `ptr`: Pointer, `groupId`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_method_client_signing_identity(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_clone_extension(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_free_extension(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_clone_extensionlist(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_free_extensionlist(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_clone_group(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_free_group(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_method_group_add_members(
        `ptr`: Pointer, `keyPackages`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_group_commit(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_group_encrypt_application_message(
        `ptr`: Pointer, `message`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_method_group_export_tree(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_group_process_incoming_message(
        `ptr`: Pointer, `message`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_group_propose_add_members(
        `ptr`: Pointer, `keyPackages`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_group_propose_remove_members(
        `ptr`: Pointer, `signingIdentities`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_group_remove_members(
        `ptr`: Pointer, `signingIdentities`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_group_write_to_storage(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_clone_groupstatestorage(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_free_groupstatestorage(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_init_callback_vtable_groupstatestorage(
        `vtable`: UniffiVTableCallbackInterfaceGroupStateStorage,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_method_groupstatestorage_state(
        `ptr`: Pointer, `groupId`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_groupstatestorage_epoch(
        `ptr`: Pointer, `groupId`: RustBuffer.ByValue, `epochId`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_method_groupstatestorage_write(
        `ptr`: Pointer,
        `groupId`: RustBuffer.ByValue,
        `groupState`: RustBuffer.ByValue,
        `epochInserts`: RustBuffer.ByValue,
        `epochUpdates`: RustBuffer.ByValue,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_method_groupstatestorage_max_epoch_id(
        `ptr`: Pointer, `groupId`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_clone_message(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_free_message(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_clone_proposal(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_free_proposal(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_clone_signingidentity(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_mls_rs_uniffi_fn_free_signingidentity(
        `ptr`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_fn_method_signingidentity_uniffi_trait_eq_eq(
        `ptr`: Pointer, `other`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Byte

    fun uniffi_mls_rs_uniffi_fn_method_signingidentity_uniffi_trait_eq_ne(
        `ptr`: Pointer, `other`: Pointer, uniffi_out_err: UniffiRustCallStatus,
    ): Byte

    fun uniffi_mls_rs_uniffi_fn_func_client_config_default(
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_mls_rs_uniffi_fn_func_generate_signature_keypair(
        `cipherSuite`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_mls_rs_uniffi_rustbuffer_alloc(
        `size`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_mls_rs_uniffi_rustbuffer_from_bytes(
        `bytes`: ForeignBytes.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_mls_rs_uniffi_rustbuffer_free(
        `buf`: RustBuffer.ByValue, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun ffi_mls_rs_uniffi_rustbuffer_reserve(
        `buf`: RustBuffer.ByValue, `additional`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_mls_rs_uniffi_rust_future_poll_u8(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_u8(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_u8(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_u8(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Byte

    fun ffi_mls_rs_uniffi_rust_future_poll_i8(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_i8(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_i8(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_i8(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Byte

    fun ffi_mls_rs_uniffi_rust_future_poll_u16(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_u16(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_u16(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_u16(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Short

    fun ffi_mls_rs_uniffi_rust_future_poll_i16(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_i16(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_i16(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_i16(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Short

    fun ffi_mls_rs_uniffi_rust_future_poll_u32(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_u32(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_u32(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_u32(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Int

    fun ffi_mls_rs_uniffi_rust_future_poll_i32(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_i32(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_i32(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_i32(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Int

    fun ffi_mls_rs_uniffi_rust_future_poll_u64(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_u64(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_u64(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_u64(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Long

    fun ffi_mls_rs_uniffi_rust_future_poll_i64(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_i64(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_i64(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_i64(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Long

    fun ffi_mls_rs_uniffi_rust_future_poll_f32(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_f32(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_f32(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_f32(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Float

    fun ffi_mls_rs_uniffi_rust_future_poll_f64(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_f64(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_f64(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_f64(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Double

    fun ffi_mls_rs_uniffi_rust_future_poll_pointer(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_pointer(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_pointer(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_pointer(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun ffi_mls_rs_uniffi_rust_future_poll_rust_buffer(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_rust_buffer(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_rust_buffer(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_rust_buffer(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_mls_rs_uniffi_rust_future_poll_void(
        `handle`: Long, `callback`: UniffiRustFutureContinuationCallback, `callbackData`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_cancel_void(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_free_void(
        `handle`: Long,
    ): Unit

    fun ffi_mls_rs_uniffi_rust_future_complete_void(
        `handle`: Long, uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_mls_rs_uniffi_checksum_func_client_config_default(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_func_generate_signature_keypair(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_client_create_group(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_client_generate_key_package_message(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_client_join_group(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_client_load_group(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_client_signing_identity(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_add_members(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_commit(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_encrypt_application_message(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_export_tree(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_process_incoming_message(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_propose_add_members(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_propose_remove_members(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_remove_members(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_group_write_to_storage(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_groupstatestorage_state(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_groupstatestorage_epoch(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_groupstatestorage_write(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_method_groupstatestorage_max_epoch_id(
    ): Short

    fun uniffi_mls_rs_uniffi_checksum_constructor_client_new(
    ): Short

    fun ffi_mls_rs_uniffi_uniffi_contract_version(
    ): Int

}

private fun uniffiCheckContractApiVersion(lib: UniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_mls_rs_uniffi_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: UniffiLib) {
    if (lib.uniffi_mls_rs_uniffi_checksum_func_client_config_default() != 59081.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_func_generate_signature_keypair() != 7255.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_client_create_group() != 51396.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_client_generate_key_package_message() != 59803.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_client_join_group() != 25011.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_client_load_group() != 56228.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_client_signing_identity() != 45906.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_add_members() != 25086.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_commit() != 61236.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_encrypt_application_message() != 52772.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_export_tree() != 57366.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_process_incoming_message() != 54676.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_propose_add_members() != 53017.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_propose_remove_members() != 64305.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_remove_members() != 44981.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_group_write_to_storage() != 36882.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_groupstatestorage_state() != 29291.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_groupstatestorage_epoch() != 34987.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_groupstatestorage_write() != 39480.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_method_groupstatestorage_max_epoch_id() != 1285.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_mls_rs_uniffi_checksum_constructor_client_new() != 21128.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// Async support

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()

    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** Used to instantiate an interface without an actual pointer, for fakes in tests, mostly. */
object NoPointer

public object FfiConverterULong : FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

public object FfiConverterBoolean : FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

public object FfiConverterString : FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

public object FfiConverterByteArray : FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }

    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }

    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


// The cleaner interface for Object finalization code to run.
// This is the entry point to any implementation that we're using.
//
// The cleaner registers objects and returns cleanables, so now we are
// defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
// different implmentations available at compile time.
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        //  otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * An MLS client used to create key packages and manage groups.
 *
 * See [`mls_rs::Client`] for details.
 */
public interface ClientInterface {

    /**
     * Create and immediately join a new group.
     *
     * If a group ID is not given, the underlying library will create
     * a unique ID for you.
     *
     * See [`mls_rs::Client::create_group`] and
     * [`mls_rs::Client::create_group_with_id`] for details.
     */
    fun `createGroup`(`groupId`: kotlin.ByteArray?): Group

    /**
     * Generate a new key package for this client.
     *
     * The key package is represented in is MLS message form. It is
     * needed when joining a group and can be published to a server
     * so other clients can look it up.
     *
     * See [`mls_rs::Client::generate_key_package_message`] for
     * details.
     */
    fun `generateKeyPackageMessage`(): Message

    /**
     * Join an existing group.
     *
     * You must supply `ratchet_tree` if the client that created
     * `welcome_message` did not set `use_ratchet_tree_extension`.
     *
     * See [`mls_rs::Client::join_group`] for details.
     */
    fun `joinGroup`(`ratchetTree`: RatchetTree?, `welcomeMessage`: Message): JoinInfo

    /**
     * Load an existing group.
     *
     * See [`mls_rs::Client::load_group`] for details.
     */
    fun `loadGroup`(`groupId`: kotlin.ByteArray): Group

    fun `signingIdentity`(): SigningIdentity

    companion object
}

/**
 * An MLS client used to create key packages and manage groups.
 *
 * See [`mls_rs::Client`] for details.
 */
open class Client : Disposable, AutoCloseable, ClientInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * Create a new client.
     *
     * The user is identified by `id`, which will be used to create a
     * basic credential together with the signature keypair.
     *
     * See [`mls_rs::Client::builder`] for details.
     */
    constructor(`id`: kotlin.ByteArray, `signatureKeypair`: SignatureKeypair, `clientConfig`: ClientConfig) :
            this(
                uniffiRustCall() { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_constructor_client_new(
                        FfiConverterByteArray.lower(`id`),
                        FfiConverterTypeSignatureKeypair.lower(`signatureKeypair`),
                        FfiConverterTypeClientConfig.lower(`clientConfig`),
                        _status
                    )
                }
            )

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_free_client(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_clone_client(pointer!!, status)
        }
    }


    /**
     * Create and immediately join a new group.
     *
     * If a group ID is not given, the underlying library will create
     * a unique ID for you.
     *
     * See [`mls_rs::Client::create_group`] and
     * [`mls_rs::Client::create_group_with_id`] for details.
     */
    @Throws(Exception::class)
    override fun `createGroup`(`groupId`: kotlin.ByteArray?): Group {
        return FfiConverterTypeGroup.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_client_create_group(
                        it, FfiConverterOptionalByteArray.lower(`groupId`), _status
                    )
                }
            }
        )
    }


    /**
     * Generate a new key package for this client.
     *
     * The key package is represented in is MLS message form. It is
     * needed when joining a group and can be published to a server
     * so other clients can look it up.
     *
     * See [`mls_rs::Client::generate_key_package_message`] for
     * details.
     */
    @Throws(Exception::class)
    override fun `generateKeyPackageMessage`(): Message {
        return FfiConverterTypeMessage.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_client_generate_key_package_message(
                        it, _status
                    )
                }
            }
        )
    }


    /**
     * Join an existing group.
     *
     * You must supply `ratchet_tree` if the client that created
     * `welcome_message` did not set `use_ratchet_tree_extension`.
     *
     * See [`mls_rs::Client::join_group`] for details.
     */
    @Throws(Exception::class)
    override fun `joinGroup`(`ratchetTree`: RatchetTree?, `welcomeMessage`: Message): JoinInfo {
        return FfiConverterTypeJoinInfo.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_client_join_group(
                        it,
                        FfiConverterOptionalTypeRatchetTree.lower(`ratchetTree`),
                        FfiConverterTypeMessage.lower(`welcomeMessage`),
                        _status
                    )
                }
            }
        )
    }


    /**
     * Load an existing group.
     *
     * See [`mls_rs::Client::load_group`] for details.
     */
    @Throws(Exception::class)
    override fun `loadGroup`(`groupId`: kotlin.ByteArray): Group {
        return FfiConverterTypeGroup.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_client_load_group(
                        it, FfiConverterByteArray.lower(`groupId`), _status
                    )
                }
            }
        )
    }


    @Throws(Exception::class)
    override fun `signingIdentity`(): SigningIdentity {
        return FfiConverterTypeSigningIdentity.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_client_signing_identity(
                        it, _status
                    )
                }
            }
        )
    }


    companion object

}

public object FfiConverterTypeClient : FfiConverter<Client, Pointer> {

    override fun lower(value: Client): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Client {
        return Client(value)
    }

    override fun read(buf: ByteBuffer): Client {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Client) = 8UL

    override fun write(value: Client, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A [`mls_rs::Extension`] wrapper.
 */
public interface ExtensionInterface {

    companion object
}

/**
 * A [`mls_rs::Extension`] wrapper.
 */
open class Extension : Disposable, AutoCloseable, ExtensionInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_free_extension(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_clone_extension(pointer!!, status)
        }
    }


    companion object

}

public object FfiConverterTypeExtension : FfiConverter<Extension, Pointer> {

    override fun lower(value: Extension): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Extension {
        return Extension(value)
    }

    override fun read(buf: ByteBuffer): Extension {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Extension) = 8UL

    override fun write(value: Extension, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A [`mls_rs::ExtensionList`] wrapper.
 */
public interface ExtensionListInterface {

    companion object
}

/**
 * A [`mls_rs::ExtensionList`] wrapper.
 */
open class ExtensionList : Disposable, AutoCloseable, ExtensionListInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_free_extensionlist(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_clone_extensionlist(pointer!!, status)
        }
    }


    companion object

}

public object FfiConverterTypeExtensionList : FfiConverter<ExtensionList, Pointer> {

    override fun lower(value: ExtensionList): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): ExtensionList {
        return ExtensionList(value)
    }

    override fun read(buf: ByteBuffer): ExtensionList {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ExtensionList) = 8UL

    override fun write(value: ExtensionList, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * An MLS end-to-end encrypted group.
 *
 * The group is used to send and process incoming messages and to
 * add/remove users.
 *
 * See [`mls_rs::Group`] for details.
 */
public interface GroupInterface {

    /**
     * Commit the addition of one or more members.
     *
     * The members are representated by key packages. The result is
     * the welcome messages to send to the new members.
     *
     * See [`mls_rs::group::CommitBuilder::add_member`] for details.
     */
    fun `addMembers`(`keyPackages`: List<Message>): CommitOutput

    /**
     * Perform a commit of received proposals (or an empty commit).
     *
     * TODO: ensure `path_required` is always set in
     * [`MlsRules::commit_options`](`mls_rs::MlsRules::commit_options`).
     *
     * Returns the resulting commit message. See
     * [`mls_rs::Group::commit`] for details.
     */
    fun `commit`(): CommitOutput

    /**
     * Encrypt an application message using the current group state.
     *
     * An application message is an application-specific payload,
     * e.g., an UTF-8 encoded text message in a chat app. The
     * encoding is not determined by MLS and applications will have
     * to implement their own mechanism for how to agree on the
     * content encoding.
     *
     * The other group members will find the message in
     * [`ReceivedMessage::ApplicationMessage`] after calling
     * [`Group::process_incoming_message`].
     */
    fun `encryptApplicationMessage`(`message`: kotlin.ByteArray): Message

    /**
     * Export the current epoch's ratchet tree in serialized format.
     *
     * This function is used to provide the current group tree to new
     * members when `use_ratchet_tree_extension` is set to false in
     * `ClientConfig`.
     */
    fun `exportTree`(): RatchetTree

    /**
     * Process an inbound message for this group.
     */
    fun `processIncomingMessage`(`message`: Message): ReceivedMessage

    /**
     * Propose to add one or more members to this group.
     *
     * The members are representated by key packages. The result is
     * the proposal messages to send to the group.
     *
     * See [`mls_rs::Group::propose_add`] for details.
     */
    fun `proposeAddMembers`(`keyPackages`: List<Message>): List<Message>

    /**
     * Propose to remove one or more members from this group.
     *
     * The members are representated by their signing identities. The
     * result is the proposal messages to send to the group.
     *
     * See [`mls_rs::group::Group::propose_remove`] for details.
     */
    fun `proposeRemoveMembers`(`signingIdentities`: List<SigningIdentity>): List<Message>

    /**
     * Propose and commit the removal of one or more members.
     *
     * The members are representated by their signing identities.
     *
     * See [`mls_rs::group::CommitBuilder::remove_member`] for details.
     */
    fun `removeMembers`(`signingIdentities`: List<SigningIdentity>): CommitOutput

    /**
     * Write the current state of the group to storage defined by
     * [`ClientConfig::group_state_storage`]
     */
    fun `writeToStorage`()

    companion object
}

/**
 * An MLS end-to-end encrypted group.
 *
 * The group is used to send and process incoming messages and to
 * add/remove users.
 *
 * See [`mls_rs::Group`] for details.
 */
open class Group : Disposable, AutoCloseable, GroupInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_free_group(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_clone_group(pointer!!, status)
        }
    }


    /**
     * Commit the addition of one or more members.
     *
     * The members are representated by key packages. The result is
     * the welcome messages to send to the new members.
     *
     * See [`mls_rs::group::CommitBuilder::add_member`] for details.
     */
    @Throws(Exception::class)
    override fun `addMembers`(`keyPackages`: List<Message>): CommitOutput {
        return FfiConverterTypeCommitOutput.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_add_members(
                        it, FfiConverterSequenceTypeMessage.lower(`keyPackages`), _status
                    )
                }
            }
        )
    }


    /**
     * Perform a commit of received proposals (or an empty commit).
     *
     * TODO: ensure `path_required` is always set in
     * [`MlsRules::commit_options`](`mls_rs::MlsRules::commit_options`).
     *
     * Returns the resulting commit message. See
     * [`mls_rs::Group::commit`] for details.
     */
    @Throws(Exception::class)
    override fun `commit`(): CommitOutput {
        return FfiConverterTypeCommitOutput.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_commit(
                        it, _status
                    )
                }
            }
        )
    }


    /**
     * Encrypt an application message using the current group state.
     *
     * An application message is an application-specific payload,
     * e.g., an UTF-8 encoded text message in a chat app. The
     * encoding is not determined by MLS and applications will have
     * to implement their own mechanism for how to agree on the
     * content encoding.
     *
     * The other group members will find the message in
     * [`ReceivedMessage::ApplicationMessage`] after calling
     * [`Group::process_incoming_message`].
     */
    @Throws(Exception::class)
    override fun `encryptApplicationMessage`(`message`: kotlin.ByteArray): Message {
        return FfiConverterTypeMessage.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_encrypt_application_message(
                        it, FfiConverterByteArray.lower(`message`), _status
                    )
                }
            }
        )
    }


    /**
     * Export the current epoch's ratchet tree in serialized format.
     *
     * This function is used to provide the current group tree to new
     * members when `use_ratchet_tree_extension` is set to false in
     * `ClientConfig`.
     */
    @Throws(Exception::class)
    override fun `exportTree`(): RatchetTree {
        return FfiConverterTypeRatchetTree.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_export_tree(
                        it, _status
                    )
                }
            }
        )
    }


    /**
     * Process an inbound message for this group.
     */
    @Throws(Exception::class)
    override fun `processIncomingMessage`(`message`: Message): ReceivedMessage {
        return FfiConverterTypeReceivedMessage.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_process_incoming_message(
                        it, FfiConverterTypeMessage.lower(`message`), _status
                    )
                }
            }
        )
    }


    /**
     * Propose to add one or more members to this group.
     *
     * The members are representated by key packages. The result is
     * the proposal messages to send to the group.
     *
     * See [`mls_rs::Group::propose_add`] for details.
     */
    @Throws(Exception::class)
    override fun `proposeAddMembers`(`keyPackages`: List<Message>): List<Message> {
        return FfiConverterSequenceTypeMessage.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_propose_add_members(
                        it, FfiConverterSequenceTypeMessage.lower(`keyPackages`), _status
                    )
                }
            }
        )
    }


    /**
     * Propose to remove one or more members from this group.
     *
     * The members are representated by their signing identities. The
     * result is the proposal messages to send to the group.
     *
     * See [`mls_rs::group::Group::propose_remove`] for details.
     */
    @Throws(Exception::class)
    override fun `proposeRemoveMembers`(`signingIdentities`: List<SigningIdentity>): List<Message> {
        return FfiConverterSequenceTypeMessage.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_propose_remove_members(
                        it, FfiConverterSequenceTypeSigningIdentity.lower(`signingIdentities`), _status
                    )
                }
            }
        )
    }


    /**
     * Propose and commit the removal of one or more members.
     *
     * The members are representated by their signing identities.
     *
     * See [`mls_rs::group::CommitBuilder::remove_member`] for details.
     */
    @Throws(Exception::class)
    override fun `removeMembers`(`signingIdentities`: List<SigningIdentity>): CommitOutput {
        return FfiConverterTypeCommitOutput.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_remove_members(
                        it, FfiConverterSequenceTypeSigningIdentity.lower(`signingIdentities`), _status
                    )
                }
            }
        )
    }


    /**
     * Write the current state of the group to storage defined by
     * [`ClientConfig::group_state_storage`]
     */
    @Throws(Exception::class)
    override fun `writeToStorage`() =
        callWithPointer {
            uniffiRustCallWithError(Exception) { _status ->
                UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_group_write_to_storage(
                    it, _status
                )
            }
        }


    companion object

}

public object FfiConverterTypeGroup : FfiConverter<Group, Pointer> {

    override fun lower(value: Group): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Group {
        return Group(value)
    }

    override fun read(buf: ByteBuffer): Group {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Group) = 8UL

    override fun write(value: Group, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface GroupStateStorage {

    fun `state`(`groupId`: kotlin.ByteArray): kotlin.ByteArray?

    fun `epoch`(`groupId`: kotlin.ByteArray, `epochId`: kotlin.ULong): kotlin.ByteArray?

    fun `write`(
        `groupId`: kotlin.ByteArray,
        `groupState`: kotlin.ByteArray,
        `epochInserts`: List<EpochRecord>,
        `epochUpdates`: List<EpochRecord>
    )

    fun `maxEpochId`(`groupId`: kotlin.ByteArray): kotlin.ULong?

    companion object
}

open class GroupStateStorageImpl : Disposable, AutoCloseable, GroupStateStorage {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_free_groupstatestorage(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_clone_groupstatestorage(pointer!!, status)
        }
    }


    @Throws(Exception::class)
    override fun `state`(`groupId`: kotlin.ByteArray): kotlin.ByteArray? {
        return FfiConverterOptionalByteArray.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_groupstatestorage_state(
                        it, FfiConverterByteArray.lower(`groupId`), _status
                    )
                }
            }
        )
    }


    @Throws(Exception::class)
    override fun `epoch`(`groupId`: kotlin.ByteArray, `epochId`: kotlin.ULong): kotlin.ByteArray? {
        return FfiConverterOptionalByteArray.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_groupstatestorage_epoch(
                        it, FfiConverterByteArray.lower(`groupId`), FfiConverterULong.lower(`epochId`), _status
                    )
                }
            }
        )
    }


    @Throws(Exception::class)
    override fun `write`(
        `groupId`: kotlin.ByteArray,
        `groupState`: kotlin.ByteArray,
        `epochInserts`: List<EpochRecord>,
        `epochUpdates`: List<EpochRecord>
    ) =
        callWithPointer {
            uniffiRustCallWithError(Exception) { _status ->
                UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_groupstatestorage_write(
                    it,
                    FfiConverterByteArray.lower(`groupId`),
                    FfiConverterByteArray.lower(`groupState`),
                    FfiConverterSequenceTypeEpochRecord.lower(`epochInserts`),
                    FfiConverterSequenceTypeEpochRecord.lower(`epochUpdates`),
                    _status
                )
            }
        }


    @Throws(Exception::class)
    override fun `maxEpochId`(`groupId`: kotlin.ByteArray): kotlin.ULong? {
        return FfiConverterOptionalULong.lift(
            callWithPointer {
                uniffiRustCallWithError(Exception) { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_groupstatestorage_max_epoch_id(
                        it, FfiConverterByteArray.lower(`groupId`), _status
                    )
                }
            }
        )
    }


    companion object

}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0

// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

public abstract class FfiConverterCallbackInterface<CallbackInterface : Any> : FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}

// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceGroupStateStorage {
    internal object `state` : UniffiCallbackInterfaceGroupStateStorageMethod0 {
        override fun callback(
            `uniffiHandle`: Long,
            `groupId`: RustBuffer.ByValue,
            `uniffiOutReturn`: RustBuffer,
            uniffiCallStatus: UniffiRustCallStatus,
        ) {
            val uniffiObj = FfiConverterTypeGroupStateStorage.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`state`(
                    FfiConverterByteArray.lift(`groupId`),
                )
            }
            val writeReturn =
                { value: kotlin.ByteArray? -> uniffiOutReturn.setValue(FfiConverterOptionalByteArray.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: Exception -> FfiConverterTypeError.lower(e) }
            )
        }
    }

    internal object `epoch` : UniffiCallbackInterfaceGroupStateStorageMethod1 {
        override fun callback(
            `uniffiHandle`: Long,
            `groupId`: RustBuffer.ByValue,
            `epochId`: Long,
            `uniffiOutReturn`: RustBuffer,
            uniffiCallStatus: UniffiRustCallStatus,
        ) {
            val uniffiObj = FfiConverterTypeGroupStateStorage.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`epoch`(
                    FfiConverterByteArray.lift(`groupId`),
                    FfiConverterULong.lift(`epochId`),
                )
            }
            val writeReturn =
                { value: kotlin.ByteArray? -> uniffiOutReturn.setValue(FfiConverterOptionalByteArray.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: Exception -> FfiConverterTypeError.lower(e) }
            )
        }
    }

    internal object `write` : UniffiCallbackInterfaceGroupStateStorageMethod2 {
        override fun callback(
            `uniffiHandle`: Long,
            `groupId`: RustBuffer.ByValue,
            `groupState`: RustBuffer.ByValue,
            `epochInserts`: RustBuffer.ByValue,
            `epochUpdates`: RustBuffer.ByValue,
            `uniffiOutReturn`: Pointer,
            uniffiCallStatus: UniffiRustCallStatus,
        ) {
            val uniffiObj = FfiConverterTypeGroupStateStorage.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`write`(
                    FfiConverterByteArray.lift(`groupId`),
                    FfiConverterByteArray.lift(`groupState`),
                    FfiConverterSequenceTypeEpochRecord.lift(`epochInserts`),
                    FfiConverterSequenceTypeEpochRecord.lift(`epochUpdates`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: Exception -> FfiConverterTypeError.lower(e) }
            )
        }
    }

    internal object `maxEpochId` : UniffiCallbackInterfaceGroupStateStorageMethod3 {
        override fun callback(
            `uniffiHandle`: Long,
            `groupId`: RustBuffer.ByValue,
            `uniffiOutReturn`: RustBuffer,
            uniffiCallStatus: UniffiRustCallStatus,
        ) {
            val uniffiObj = FfiConverterTypeGroupStateStorage.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`maxEpochId`(
                    FfiConverterByteArray.lift(`groupId`),
                )
            }
            val writeReturn =
                { value: kotlin.ULong? -> uniffiOutReturn.setValue(FfiConverterOptionalULong.lower(value)) }
            uniffiTraitInterfaceCallWithError(
                uniffiCallStatus,
                makeCall,
                writeReturn,
                { e: Exception -> FfiConverterTypeError.lower(e) }
            )
        }
    }

    internal object uniffiFree : UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeGroupStateStorage.handleMap.remove(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceGroupStateStorage.UniffiByValue(
        `state`,
        `epoch`,
        `write`,
        `maxEpochId`,
        uniffiFree,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_mls_rs_uniffi_fn_init_callback_vtable_groupstatestorage(vtable)
    }
}

public object FfiConverterTypeGroupStateStorage : FfiConverter<GroupStateStorage, Pointer> {
    internal val handleMap = UniffiHandleMap<GroupStateStorage>()

    override fun lower(value: GroupStateStorage): Pointer {
        return Pointer(handleMap.insert(value))
    }

    override fun lift(value: Pointer): GroupStateStorage {
        return GroupStateStorageImpl(value)
    }

    override fun read(buf: ByteBuffer): GroupStateStorage {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: GroupStateStorage) = 8UL

    override fun write(value: GroupStateStorage, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * A [`mls_rs::MlsMessage`] wrapper.
 */
public interface MessageInterface {

    companion object
}

/**
 * A [`mls_rs::MlsMessage`] wrapper.
 */
open class Message : Disposable, AutoCloseable, MessageInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_free_message(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_clone_message(pointer!!, status)
        }
    }


    companion object

}

public object FfiConverterTypeMessage : FfiConverter<Message, Pointer> {

    override fun lower(value: Message): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Message {
        return Message(value)
    }

    override fun read(buf: ByteBuffer): Message {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Message) = 8UL

    override fun write(value: Message, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ProposalInterface {

    companion object
}

open class Proposal : Disposable, AutoCloseable, ProposalInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_free_proposal(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_clone_proposal(pointer!!, status)
        }
    }


    companion object

}

public object FfiConverterTypeProposal : FfiConverter<Proposal, Pointer> {

    override fun lower(value: Proposal): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): Proposal {
        return Proposal(value)
    }

    override fun read(buf: ByteBuffer): Proposal {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Proposal) = 8UL

    override fun write(value: Proposal, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SigningIdentityInterface {

    companion object
}

open class SigningIdentity : Disposable, AutoCloseable, SigningIdentityInterface {

    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val pointer: Pointer?) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_free_signingidentity(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer {
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_clone_signingidentity(pointer!!, status)
        }
    }


    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is SigningIdentity) return false
        return FfiConverterBoolean.lift(
            callWithPointer {
                uniffiRustCall() { _status ->
                    UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_method_signingidentity_uniffi_trait_eq_eq(
                        it, FfiConverterTypeSigningIdentity.lower(`other`), _status
                    )
                }
            }
        )
    }


    companion object

}

public object FfiConverterTypeSigningIdentity : FfiConverter<SigningIdentity, Pointer> {

    override fun lower(value: SigningIdentity): Pointer {
        return value.uniffiClonePointer()
    }

    override fun lift(value: Pointer): SigningIdentity {
        return SigningIdentity(value)
    }

    override fun read(buf: ByteBuffer): SigningIdentity {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SigningIdentity) = 8UL

    override fun write(value: SigningIdentity, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}


data class ClientConfig(
    var `groupStateStorage`: GroupStateStorage,
    /**
     * Use the ratchet tree extension. If this is false, then you
     * must supply `ratchet_tree` out of band to clients.
     */
    var `useRatchetTreeExtension`: kotlin.Boolean
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {

        Disposable.destroy(
            this.`groupStateStorage`,
            this.`useRatchetTreeExtension`
        )
    }

    companion object
}

public object FfiConverterTypeClientConfig : FfiConverterRustBuffer<ClientConfig> {
    override fun read(buf: ByteBuffer): ClientConfig {
        return ClientConfig(
            FfiConverterTypeGroupStateStorage.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ClientConfig) = (
            FfiConverterTypeGroupStateStorage.allocationSize(value.`groupStateStorage`) +
                    FfiConverterBoolean.allocationSize(value.`useRatchetTreeExtension`)
            )

    override fun write(value: ClientConfig, buf: ByteBuffer) {
        FfiConverterTypeGroupStateStorage.write(value.`groupStateStorage`, buf)
        FfiConverterBoolean.write(value.`useRatchetTreeExtension`, buf)
    }
}


data class CommitOutput(
    /**
     * Commit message to send to other group members.
     */
    var `commitMessage`: Message,
    /**
     * Welcome message to send to new group members. This will be
     * `None` if the commit did not add new members.
     */
    var `welcomeMessage`: Message?,
    /**
     * Ratchet tree that can be sent out of band if the ratchet tree
     * extension is not used.
     */
    var `ratchetTree`: RatchetTree?,
    /**
     * A group info that can be provided to new members in order to
     * enable external commit functionality.
     */
    var `groupInfo`: Message?
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {

        Disposable.destroy(
            this.`commitMessage`,
            this.`welcomeMessage`,
            this.`ratchetTree`,
            this.`groupInfo`
        )
    }

    companion object
}

public object FfiConverterTypeCommitOutput : FfiConverterRustBuffer<CommitOutput> {
    override fun read(buf: ByteBuffer): CommitOutput {
        return CommitOutput(
            FfiConverterTypeMessage.read(buf),
            FfiConverterOptionalTypeMessage.read(buf),
            FfiConverterOptionalTypeRatchetTree.read(buf),
            FfiConverterOptionalTypeMessage.read(buf),
        )
    }

    override fun allocationSize(value: CommitOutput) = (
            FfiConverterTypeMessage.allocationSize(value.`commitMessage`) +
                    FfiConverterOptionalTypeMessage.allocationSize(value.`welcomeMessage`) +
                    FfiConverterOptionalTypeRatchetTree.allocationSize(value.`ratchetTree`) +
                    FfiConverterOptionalTypeMessage.allocationSize(value.`groupInfo`)
            )

    override fun write(value: CommitOutput, buf: ByteBuffer) {
        FfiConverterTypeMessage.write(value.`commitMessage`, buf)
        FfiConverterOptionalTypeMessage.write(value.`welcomeMessage`, buf)
        FfiConverterOptionalTypeRatchetTree.write(value.`ratchetTree`, buf)
        FfiConverterOptionalTypeMessage.write(value.`groupInfo`, buf)
    }
}


data class EpochRecord(
    /**
     * A unique epoch identifier within a particular group.
     */
    var `id`: kotlin.ULong,
    var `data`: kotlin.ByteArray
) {

    companion object
}

public object FfiConverterTypeEpochRecord : FfiConverterRustBuffer<EpochRecord> {
    override fun read(buf: ByteBuffer): EpochRecord {
        return EpochRecord(
            FfiConverterULong.read(buf),
            FfiConverterByteArray.read(buf),
        )
    }

    override fun allocationSize(value: EpochRecord) = (
            FfiConverterULong.allocationSize(value.`id`) +
                    FfiConverterByteArray.allocationSize(value.`data`)
            )

    override fun write(value: EpochRecord, buf: ByteBuffer) {
        FfiConverterULong.write(value.`id`, buf)
        FfiConverterByteArray.write(value.`data`, buf)
    }
}


/**
 * A [`mls_rs::Group`] and [`mls_rs::group::NewMemberInfo`] wrapper.
 */
data class JoinInfo(
    /**
     * The group that was joined.
     */
    var `group`: Group,
    /**
     * Group info extensions found within the Welcome message used to join
     * the group.
     */
    var `groupInfoExtensions`: ExtensionList
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {

        Disposable.destroy(
            this.`group`,
            this.`groupInfoExtensions`
        )
    }

    companion object
}

public object FfiConverterTypeJoinInfo : FfiConverterRustBuffer<JoinInfo> {
    override fun read(buf: ByteBuffer): JoinInfo {
        return JoinInfo(
            FfiConverterTypeGroup.read(buf),
            FfiConverterTypeExtensionList.read(buf),
        )
    }

    override fun allocationSize(value: JoinInfo) = (
            FfiConverterTypeGroup.allocationSize(value.`group`) +
                    FfiConverterTypeExtensionList.allocationSize(value.`groupInfoExtensions`)
            )

    override fun write(value: JoinInfo, buf: ByteBuffer) {
        FfiConverterTypeGroup.write(value.`group`, buf)
        FfiConverterTypeExtensionList.write(value.`groupInfoExtensions`, buf)
    }
}


data class RatchetTree(
    var `bytes`: kotlin.ByteArray
) {

    companion object
}

public object FfiConverterTypeRatchetTree : FfiConverterRustBuffer<RatchetTree> {
    override fun read(buf: ByteBuffer): RatchetTree {
        return RatchetTree(
            FfiConverterByteArray.read(buf),
        )
    }

    override fun allocationSize(value: RatchetTree) = (
            FfiConverterByteArray.allocationSize(value.`bytes`)
            )

    override fun write(value: RatchetTree, buf: ByteBuffer) {
        FfiConverterByteArray.write(value.`bytes`, buf)
    }
}


/**
 * A ([`SignaturePublicKey`], [`SignatureSecretKey`]) pair.
 */
data class SignatureKeypair(
    var `cipherSuite`: CipherSuite,
    var `publicKey`: SignaturePublicKey,
    var `secretKey`: SignatureSecretKey
) {

    companion object
}

public object FfiConverterTypeSignatureKeypair : FfiConverterRustBuffer<SignatureKeypair> {
    override fun read(buf: ByteBuffer): SignatureKeypair {
        return SignatureKeypair(
            FfiConverterTypeCipherSuite.read(buf),
            FfiConverterTypeSignaturePublicKey.read(buf),
            FfiConverterTypeSignatureSecretKey.read(buf),
        )
    }

    override fun allocationSize(value: SignatureKeypair) = (
            FfiConverterTypeCipherSuite.allocationSize(value.`cipherSuite`) +
                    FfiConverterTypeSignaturePublicKey.allocationSize(value.`publicKey`) +
                    FfiConverterTypeSignatureSecretKey.allocationSize(value.`secretKey`)
            )

    override fun write(value: SignatureKeypair, buf: ByteBuffer) {
        FfiConverterTypeCipherSuite.write(value.`cipherSuite`, buf)
        FfiConverterTypeSignaturePublicKey.write(value.`publicKey`, buf)
        FfiConverterTypeSignatureSecretKey.write(value.`secretKey`, buf)
    }
}


/**
 * A [`mls_rs::crypto::SignaturePublicKey`] wrapper.
 */
data class SignaturePublicKey(
    var `bytes`: kotlin.ByteArray
) {

    companion object
}

public object FfiConverterTypeSignaturePublicKey : FfiConverterRustBuffer<SignaturePublicKey> {
    override fun read(buf: ByteBuffer): SignaturePublicKey {
        return SignaturePublicKey(
            FfiConverterByteArray.read(buf),
        )
    }

    override fun allocationSize(value: SignaturePublicKey) = (
            FfiConverterByteArray.allocationSize(value.`bytes`)
            )

    override fun write(value: SignaturePublicKey, buf: ByteBuffer) {
        FfiConverterByteArray.write(value.`bytes`, buf)
    }
}


/**
 * A [`mls_rs::crypto::SignatureSecretKey`] wrapper.
 */
data class SignatureSecretKey(
    var `bytes`: kotlin.ByteArray
) {

    companion object
}

public object FfiConverterTypeSignatureSecretKey : FfiConverterRustBuffer<SignatureSecretKey> {
    override fun read(buf: ByteBuffer): SignatureSecretKey {
        return SignatureSecretKey(
            FfiConverterByteArray.read(buf),
        )
    }

    override fun allocationSize(value: SignatureSecretKey) = (
            FfiConverterByteArray.allocationSize(value.`bytes`)
            )

    override fun write(value: SignatureSecretKey, buf: ByteBuffer) {
        FfiConverterByteArray.write(value.`bytes`, buf)
    }
}


/**
 * Supported cipher suites.
 *
 * This is a subset of the cipher suites found in
 * [`mls_rs::CipherSuite`].
 */

enum class CipherSuite {

    CURVE25519_AES128;

    companion object
}


public object FfiConverterTypeCipherSuite : FfiConverterRustBuffer<CipherSuite> {
    override fun read(buf: ByteBuffer) = try {
        CipherSuite.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: CipherSuite) = 4UL

    override fun write(value: CipherSuite, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}


sealed class CommitEffect : Disposable {

    data class NewEpoch(
        val `appliedProposals`: List<Proposal>,
        val `unusedProposals`: List<Proposal>
    ) : CommitEffect() {
        companion object
    }

    object ReInit : CommitEffect()


    object Removed : CommitEffect()


    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when (this) {
            is CommitEffect.NewEpoch -> {

                Disposable.destroy(
                    this.`appliedProposals`,
                    this.`unusedProposals`
                )

            }

            is CommitEffect.ReInit -> {// Nothing to destroy
            }

            is CommitEffect.Removed -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

    companion object
}

public object FfiConverterTypeCommitEffect : FfiConverterRustBuffer<CommitEffect> {
    override fun read(buf: ByteBuffer): CommitEffect {
        return when (buf.getInt()) {
            1 -> CommitEffect.NewEpoch(
                FfiConverterSequenceTypeProposal.read(buf),
                FfiConverterSequenceTypeProposal.read(buf),
            )

            2 -> CommitEffect.ReInit
            3 -> CommitEffect.Removed
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CommitEffect) = when (value) {
        is CommitEffect.NewEpoch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                            + FfiConverterSequenceTypeProposal.allocationSize(value.`appliedProposals`)
                            + FfiConverterSequenceTypeProposal.allocationSize(value.`unusedProposals`)
                    )
        }

        is CommitEffect.ReInit -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                    )
        }

        is CommitEffect.Removed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                    )
        }
    }

    override fun write(value: CommitEffect, buf: ByteBuffer) {
        when (value) {
            is CommitEffect.NewEpoch -> {
                buf.putInt(1)
                FfiConverterSequenceTypeProposal.write(value.`appliedProposals`, buf)
                FfiConverterSequenceTypeProposal.write(value.`unusedProposals`, buf)
                Unit
            }

            is CommitEffect.ReInit -> {
                buf.putInt(2)
                Unit
            }

            is CommitEffect.Removed -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}


sealed class Exception(message: String) : kotlin.Exception(message) {

    class MlsException(message: String) : Exception(message)

    class AnyException(message: String) : Exception(message)

    class MlsCodecException(message: String) : Exception(message)

    class UnexpectedCallbackException(message: String) : Exception(message)


    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<Exception> {
        override fun lift(error_buf: RustBuffer.ByValue): Exception = FfiConverterTypeError.lift(error_buf)
    }
}

public object FfiConverterTypeError : FfiConverterRustBuffer<Exception> {
    override fun read(buf: ByteBuffer): Exception {

        return when (buf.getInt()) {
            1 -> Exception.MlsException(FfiConverterString.read(buf))
            2 -> Exception.AnyException(FfiConverterString.read(buf))
            3 -> Exception.MlsCodecException(FfiConverterString.read(buf))
            4 -> Exception.UnexpectedCallbackException(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    }

    override fun allocationSize(value: Exception): ULong {
        return 4UL
    }

    override fun write(value: Exception, buf: ByteBuffer) {
        when (value) {
            is Exception.MlsException -> {
                buf.putInt(1)
                Unit
            }

            is Exception.AnyException -> {
                buf.putInt(2)
                Unit
            }

            is Exception.MlsCodecException -> {
                buf.putInt(3)
                Unit
            }

            is Exception.UnexpectedCallbackException -> {
                buf.putInt(4)
                Unit
            }

            else -> Unit
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}


enum class ProtocolVersion {

    /**
     * MLS version 1.0.
     */
    MLS10;

    companion object
}


public object FfiConverterTypeProtocolVersion : FfiConverterRustBuffer<ProtocolVersion> {
    override fun read(buf: ByteBuffer) = try {
        ProtocolVersion.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ProtocolVersion) = 4UL

    override fun write(value: ProtocolVersion, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}


/**
 * A [`mls_rs::group::ReceivedMessage`] wrapper.
 */
sealed class ReceivedMessage : Disposable {

    /**
     * A decrypted application message.
     *
     * The encoding of the data in the message is
     * application-specific and is not determined by MLS.
     */
    data class ApplicationMessage(
        val `sender`: SigningIdentity,
        val `data`: kotlin.ByteArray
    ) : ReceivedMessage() {
        companion object
    }

    /**
     * A new commit was processed creating a new group state.
     */
    data class Commit(
        val `committer`: SigningIdentity,
        val `effect`: CommitEffect
    ) : ReceivedMessage() {
        companion object
    }

    /**
     * A proposal was received.
     */
    data class ReceivedProposal(
        val `sender`: SigningIdentity,
        val `proposal`: Proposal
    ) : ReceivedMessage() {
        companion object
    }

    /**
     * Validated GroupInfo object.
     */
    object GroupInfo : ReceivedMessage()


    /**
     * Validated welcome message.
     */
    object Welcome : ReceivedMessage()


    /**
     * Validated key package.
     */
    object KeyPackage : ReceivedMessage()


    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when (this) {
            is ReceivedMessage.ApplicationMessage -> {

                Disposable.destroy(
                    this.`sender`,
                    this.`data`
                )

            }

            is ReceivedMessage.Commit -> {

                Disposable.destroy(
                    this.`committer`,
                    this.`effect`
                )

            }

            is ReceivedMessage.ReceivedProposal -> {

                Disposable.destroy(
                    this.`sender`,
                    this.`proposal`
                )

            }

            is ReceivedMessage.GroupInfo -> {// Nothing to destroy
            }

            is ReceivedMessage.Welcome -> {// Nothing to destroy
            }

            is ReceivedMessage.KeyPackage -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

    companion object
}

public object FfiConverterTypeReceivedMessage : FfiConverterRustBuffer<ReceivedMessage> {
    override fun read(buf: ByteBuffer): ReceivedMessage {
        return when (buf.getInt()) {
            1 -> ReceivedMessage.ApplicationMessage(
                FfiConverterTypeSigningIdentity.read(buf),
                FfiConverterByteArray.read(buf),
            )

            2 -> ReceivedMessage.Commit(
                FfiConverterTypeSigningIdentity.read(buf),
                FfiConverterTypeCommitEffect.read(buf),
            )

            3 -> ReceivedMessage.ReceivedProposal(
                FfiConverterTypeSigningIdentity.read(buf),
                FfiConverterTypeProposal.read(buf),
            )

            4 -> ReceivedMessage.GroupInfo
            5 -> ReceivedMessage.Welcome
            6 -> ReceivedMessage.KeyPackage
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ReceivedMessage) = when (value) {
        is ReceivedMessage.ApplicationMessage -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                            + FfiConverterTypeSigningIdentity.allocationSize(value.`sender`)
                            + FfiConverterByteArray.allocationSize(value.`data`)
                    )
        }

        is ReceivedMessage.Commit -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                            + FfiConverterTypeSigningIdentity.allocationSize(value.`committer`)
                            + FfiConverterTypeCommitEffect.allocationSize(value.`effect`)
                    )
        }

        is ReceivedMessage.ReceivedProposal -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                            + FfiConverterTypeSigningIdentity.allocationSize(value.`sender`)
                            + FfiConverterTypeProposal.allocationSize(value.`proposal`)
                    )
        }

        is ReceivedMessage.GroupInfo -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                    )
        }

        is ReceivedMessage.Welcome -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                    )
        }

        is ReceivedMessage.KeyPackage -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                    4UL
                    )
        }
    }

    override fun write(value: ReceivedMessage, buf: ByteBuffer) {
        when (value) {
            is ReceivedMessage.ApplicationMessage -> {
                buf.putInt(1)
                FfiConverterTypeSigningIdentity.write(value.`sender`, buf)
                FfiConverterByteArray.write(value.`data`, buf)
                Unit
            }

            is ReceivedMessage.Commit -> {
                buf.putInt(2)
                FfiConverterTypeSigningIdentity.write(value.`committer`, buf)
                FfiConverterTypeCommitEffect.write(value.`effect`, buf)
                Unit
            }

            is ReceivedMessage.ReceivedProposal -> {
                buf.putInt(3)
                FfiConverterTypeSigningIdentity.write(value.`sender`, buf)
                FfiConverterTypeProposal.write(value.`proposal`, buf)
                Unit
            }

            is ReceivedMessage.GroupInfo -> {
                buf.putInt(4)
                Unit
            }

            is ReceivedMessage.Welcome -> {
                buf.putInt(5)
                Unit
            }

            is ReceivedMessage.KeyPackage -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}


public object FfiConverterOptionalULong : FfiConverterRustBuffer<kotlin.ULong?> {
    override fun read(buf: ByteBuffer): kotlin.ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: kotlin.ULong?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}


public object FfiConverterOptionalByteArray : FfiConverterRustBuffer<kotlin.ByteArray?> {
    override fun read(buf: ByteBuffer): kotlin.ByteArray? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterByteArray.read(buf)
    }

    override fun allocationSize(value: kotlin.ByteArray?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterByteArray.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ByteArray?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterByteArray.write(value, buf)
        }
    }
}


public object FfiConverterOptionalTypeMessage : FfiConverterRustBuffer<Message?> {
    override fun read(buf: ByteBuffer): Message? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMessage.read(buf)
    }

    override fun allocationSize(value: Message?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeMessage.allocationSize(value)
        }
    }

    override fun write(value: Message?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMessage.write(value, buf)
        }
    }
}


public object FfiConverterOptionalTypeRatchetTree : FfiConverterRustBuffer<RatchetTree?> {
    override fun read(buf: ByteBuffer): RatchetTree? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRatchetTree.read(buf)
    }

    override fun allocationSize(value: RatchetTree?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRatchetTree.allocationSize(value)
        }
    }

    override fun write(value: RatchetTree?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRatchetTree.write(value, buf)
        }
    }
}


public object FfiConverterSequenceTypeMessage : FfiConverterRustBuffer<List<Message>> {
    override fun read(buf: ByteBuffer): List<Message> {
        val len = buf.getInt()
        return List<Message>(len) {
            FfiConverterTypeMessage.read(buf)
        }
    }

    override fun allocationSize(value: List<Message>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMessage.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Message>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMessage.write(it, buf)
        }
    }
}


public object FfiConverterSequenceTypeProposal : FfiConverterRustBuffer<List<Proposal>> {
    override fun read(buf: ByteBuffer): List<Proposal> {
        val len = buf.getInt()
        return List<Proposal>(len) {
            FfiConverterTypeProposal.read(buf)
        }
    }

    override fun allocationSize(value: List<Proposal>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeProposal.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Proposal>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeProposal.write(it, buf)
        }
    }
}


public object FfiConverterSequenceTypeSigningIdentity : FfiConverterRustBuffer<List<SigningIdentity>> {
    override fun read(buf: ByteBuffer): List<SigningIdentity> {
        val len = buf.getInt()
        return List<SigningIdentity>(len) {
            FfiConverterTypeSigningIdentity.read(buf)
        }
    }

    override fun allocationSize(value: List<SigningIdentity>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSigningIdentity.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SigningIdentity>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSigningIdentity.write(it, buf)
        }
    }
}


public object FfiConverterSequenceTypeEpochRecord : FfiConverterRustBuffer<List<EpochRecord>> {
    override fun read(buf: ByteBuffer): List<EpochRecord> {
        val len = buf.getInt()
        return List<EpochRecord>(len) {
            FfiConverterTypeEpochRecord.read(buf)
        }
    }

    override fun allocationSize(value: List<EpochRecord>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeEpochRecord.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<EpochRecord>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeEpochRecord.write(it, buf)
        }
    }
}

/**
 * Create a client config with an in-memory group state storage.
 */
fun `clientConfigDefault`(): ClientConfig {
    return FfiConverterTypeClientConfig.lift(
        uniffiRustCall() { _status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_func_client_config_default(
                _status
            )
        }
    )
}


/**
 * Generate a MLS signature keypair.
 *
 * This will use the default mls-lite crypto provider.
 *
 * See [`mls_rs::CipherSuiteProvider::signature_key_generate`]
 * for details.
 */
@Throws(Exception::class)
fun `generateSignatureKeypair`(`cipherSuite`: CipherSuite): SignatureKeypair {
    return FfiConverterTypeSignatureKeypair.lift(
        uniffiRustCallWithError(Exception) { _status ->
            UniffiLib.INSTANCE.uniffi_mls_rs_uniffi_fn_func_generate_signature_keypair(
                FfiConverterTypeCipherSuite.lower(`cipherSuite`), _status
            )
        }
    )
}
    


